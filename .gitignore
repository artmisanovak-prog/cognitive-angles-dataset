"""
Cognitive Angle Detection Evaluator
Simple script for testing angle detection in narratives
"""

import json
import numpy as np
from typing import Dict, List

class AngleDetector:
    """Simple evaluator for cognitive angle detection"""
    
    def __init__(self, angles_definition_path: str = None):
        self.angles = {
            "naive": "Direct, assumption-free observation",
            "linguistic": "Focus on language structure and ambiguity",
            "absurd": "Perception of logical contradictions",
            "philosophical": "Search for universal principles",
            "metaphorical": "Symbolic interpretation",
            "introspective": "Self-reflection and emotional projection",
            "ironical": "Detection of intention-reality discrepancies",
            "grotesque": "Exaggerated, caricatured perception",
            "socio_critical": "Analysis of power structures and social hypocrisy",
            "poetic": "Focus on rhythm, sound, and aesthetic language",
            "communal": "Collective wisdom and shared understanding",
            "capitalist_critical": "Critique of commodification",
            "ontological": "Examination of existence and possibility",
            "auditory": "Perception through sound and rhythm",
            "performative": "Embodied, gestural understanding",
            "surreal": "Free association and dream logic",
            "literal": "Fact-based, interpretation-free observation"
        }
    
    def analyze_text(self, text: str, model_output: List[str]) -> Dict:
        """
        Compare model's angle detection with gold standard
        
        Args:
            text: Input text (unused in this simple version)
            model_output: List of angles identified by model
            
        Returns:
            Dictionary with precision, recall, f1 for each angle
        """
        # In full version, this would use actual gold standard
        # For demo, we'll simulate with the first tale's angles
        gold_standard = ["naive", "linguistic", "introspective"]
        
        results = {
            "precision": self._calculate_precision(model_output, gold_standard),
            "recall": self._calculate_recall(model_output, gold_standard),
            "f1": self._calculate_f1(model_output, gold_standard),
            "detected_angles": model_output,
            "gold_angles": gold_standard
        }
        
        return results
    
    def _calculate_precision(self, predicted: List[str], gold: List[str]) -> float:
        """Precision = TP / (TP + FP)"""
        if not predicted:
            return 0.0
        true_positives = len(set(predicted) & set(gold))
        return true_positives / len(predicted)
    
    def _calculate_recall(self, predicted: List[str], gold: List[str]) -> float:
        """Recall = TP / (TP + FN)"""
        if not gold:
            return 0.0
        true_positives = len(set(predicted) & set(gold))
        return true_positives / len(gold)
    
    def _calculate_f1(self, predicted: List[str], gold: List[str]) -> float:
        """F1 = 2 * (precision * recall) / (precision + recall)"""
        precision = self._calculate_precision(predicted, gold)
        recall = self._calculate_recall(predicted, gold)
        
        if precision + recall == 0:
            return 0.0
        return 2 * (precision * recall) / (precision + recall)


def main():
    """Demo of the evaluator"""
    detector = AngleDetector()
    
    # Simulate model output (replace with actual LLM call)
    test_text = "Sample text would go here..."
    model_detected_angles = ["naive", "linguistic", "philosophical"]  # Model's guess
    
    results = detector.analyze_text(test_text, model_detected_angles)
    
    print("=== Cognitive Angle Detection Evaluation ===")
    print(f"Model detected: {results['detected_angles']}")
    print(f"Gold standard: {results['gold_angles']}")
    print(f"\nMetrics:")
    print(f"Precision: {results['precision']:.3f}")
    print(f"Recall: {results['recall']:.3f}")
    print(f"F1-Score: {results['f1']:.3f}")


if __name__ == "__main__":
    main()
